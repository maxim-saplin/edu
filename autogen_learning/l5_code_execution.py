# flake8: noqa: 266
import datetime
from llm import get_llm_config
from autogen.coding import DockerCommandLineCodeExecutor, LocalCommandLineCodeExecutor
from autogen import ConversableAgent, AssistantAgent


llm_config = get_llm_config()

# Testing "freestyle" coding, instead of tools with fixed functionality

# This one fails with "FileNotFoundError: [Errno 2] No such file or directory: 'python'"
# Likely something wrong with my python3.11 from brew
# executor = LocalCommandLineCodeExecutor(
#     timeout=5,
#     work_dir="coding",
# )

# Using Docker command line code executor instead
executor = DockerCommandLineCodeExecutor(
    image="python:3.11-slim",  # Execute code using the given docker image name.
    timeout=30,  # Timeout needs to be larger to let install dependencies
    work_dir="coding",
)


# This agent will use LLM to write Python code
code_writer_agent = AssistantAgent(
    name="code_writer_agent",
    llm_config=llm_config,
    code_execution_config=False,
    human_input_mode="NEVER",
)

# # AssistantAgent has a predefined system prompt supporting Python code generation, can be overriden
# print(code_writer_agent.system_message)

# This one will only be used as proxy agent, receive code, execute it and return it back
# It serves as a tool, not a true agent not interacting with any LLM
code_executor_agent = ConversableAgent(
    name="code_executor_agent",
    llm_config=False,
    code_execution_config={"executor": executor},
    # The proxy will display the code generated by code writer and ask the user to provide any
    # feedback or reply with empty messages if all is fine and execution can be continued
    human_input_mode="NEVER",  # Switched to NEVER to avoid manually confirming every dependency install,
    # the LLM will recieve error logs when running file in container without
    # and will produce a new python file with smth like that:
    #   def install(package):
    #       subprocess.check_call([sys.executable, "-m", "pip", "install", package])
    #   # Install required libraries
    #       install('pandas')
    default_auto_reply="Please continue. If everything is done, reply 'TERMINATE'.",
)

## Plotting stock pries

today = datetime.datetime.now().date()
# Very simple task, anything more complex will get flaky, seen it many times
message = (
    f"Today is {today}. "
    "Create a plot showing stock gain YTD for NVDA and TLSA. "
    "Make sure the code is in markdown code block and save the figure"
    " to a file ytd_stock_gains.png."
    ""
)

# Check ./coding dir fot the output plot image and source file generated and executed (which produced plot)
chat_result = code_executor_agent.initiate_chat(
    code_writer_agent,
    message=message,
)

# And I received a bar chart, not a time series as in the class at Deeplearning - who could have guessed an AI agent will fail miserably :)

## User-defined functions

# Quote from the class:
# "Instead of asking LLM to generate the code for downloading stock data and plotting charts each time,
# you can define functions for these two tasks and have LLM call these functions in the code."
# Sounds like making a tool call but without registering tools as it was done in Lesson 4, cab be
# a good alternative to situations when you have an LLM without the native support for tool calls


def get_stock_prices(stock_symbols, start_date, end_date):
    """Get the stock prices for the given stock symbols between
    the start and end dates.

    Args:
        stock_symbols (str or list): The stock symbols to get the
        prices for.
        start_date (str): The start date in the format
        'YYYY-MM-DD'.
        end_date (str): The end date in the format 'YYYY-MM-DD'.

    Returns:
        pandas.DataFrame: The stock prices for the given stock
        symbols indexed by date, with one column per stock
        symbol.
    """
    import yfinance

    stock_data = yfinance.download(stock_symbols, start=start_date, end=end_date)
    return stock_data.get("Close")


def plot_stock_prices(stock_prices, filename):
    """Plot the stock prices for the given stock symbols.

    Args:
        stock_prices (pandas.DataFrame): The stock prices for the
        given stock symbols.
    """
    import matplotlib.pyplot as plt

    plt.figure(figsize=(10, 5))
    for column in stock_prices.columns:
        plt.plot(stock_prices.index, stock_prices[column], label=column)
    plt.title("Stock Prices")
    plt.xlabel("Date")
    plt.ylabel("Price")
    plt.grid(True)
    plt.savefig(filename)


# Docker executor doesn't support `functions`, reverting back to
# local executor to peek into the pronpts
executor = LocalCommandLineCodeExecutor(
    timeout=30,
    work_dir="coding",
    functions=[get_stock_prices, plot_stock_prices],
)

# Extending the system prompt with UDFs
writer_system_prompt = AssistantAgent.DEFAULT_SYSTEM_MESSAGE
writer_system_prompt += executor.format_functions_for_prompt()
print(executor.format_functions_for_prompt())
# You have access to the following user defined functions. They can be accessed from the module called `functions` by their function names.
# For example, if there was a function called `foo` you could import it by writing `from functions import foo`
# def get_stock_prices(stock_symbols, start_date, end_date):
#     """Get the stock prices for the given stock symbols between
#         the start and end dates.
#         Args:
#             stock_symbols (str or list): The stock symbols to get the
#             prices for.
#             start_date (str): The start date in the format
#             'YYYY-MM-DD'.
#             end_date (str): The end date in the format 'YYYY-MM-DD'.
#         Returns:
#             pandas.DataFrame: The stock prices for the given stock
#             symbols indexed by date, with one column per stock
#             symbol.
#     """
#     ...
# def plot_stock_prices(stock_prices, filename):
#     """Plot the stock prices for the given stock symbols.
#         Args:
#             stock_prices (pandas.DataFrame): The stock prices for the
#             given stock symbols.
#     """
#     ...

# Essentially this code writer will create a shorter prompt that calls the user defined functions,
# a sort of workaround for tool cal by deirectly promnpting the llm to produce a python snippet
# that picks the names of UDFs
# Yet unlike tool call there doesn't seem to be a clear way to use code execution output as tool output,
# specifically ask for print?
code_writer_agent = ConversableAgent(
    name="code_writer_agent",
    system_message=writer_system_prompt,
    llm_config=llm_config,
    code_execution_config=False,
    human_input_mode="NEVER",
)

# It is indeed way shorter
# ```python
# # filename: download_and_plot_stocks.py
# from functions import get_stock_prices, plot_stock_prices
# import pandas as pd

# # Define stock symbols and date range
# stock_symbols = ['NVDA', 'TSLA']
# start_date = '2024-01-01'
# end_date = '2024-10-03'

# # Get stock prices
# stock_prices = get_stock_prices(stock_symbols, start_date, end_date)

# # Create a plot and save it
# plot_stock_prices(stock_prices, 'stock_prices_YTD_plot.png')
# ```

code_executor_agent = ConversableAgent(
    name="code_executor_agent",
    llm_config=False,
    code_execution_config={"executor": executor},
    # disablign human in the loop
    human_input_mode="NEVER",
    default_auto_reply="Please continue. If everything is done, reply 'TERMINATE'.",
)

# And this one fails cause for the same reasons as above, let's trust it works :)
chat_result = code_executor_agent.initiate_chat(
    code_writer_agent,
    message=f"Today is {today}."
    "Download the stock prices YTD for NVDA and TSLA and create"
    "a plot. Make sure the code is in markdown code block and "
    "save the figure to a file stock_prices_YTD_plot.png.",
)
